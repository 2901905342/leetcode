//根据 逆波兰表示法，求表达式的值。
//有效的算符包括  + 、 - 、 * 、 / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
//说明：
//整数除法只保留整数部分。
//给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

//逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
//
//平常使用的算式则是一种中缀表达式，如(1 + 2)* (3 + 4) 。
//该算式的逆波兰表达式写法为((1 2 + ) (3 4 + )*) 。
//逆波兰表达式主要有以下两个优点：
//
//去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + *也可以依据次序计算出正确结果。
//适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。


/////////////思路//////////////////
//方法一：栈
//逆波兰表达式严格遵循「从左到右」的运算。计算逆波兰表达式的值时，使用一个栈存储操作数，从左到右遍历逆波兰表达式，进行如下操作：
//如果遇到操作数，则将操作数入栈；
//如果遇到运算符，则将两个操作数出栈，其中先出栈的是右操作数，后出栈的是左操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈。
//整个逆波兰表达式遍历完毕之后，栈内只有一个元素，该元素即为逆波兰表达式的值。

#include "myhead.h"
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> zhan;  
        set<string>fuhao = { "+","-","*","/" };  //存储运算符
        for (int i = 0; i < tokens.size(); i++) {
            if (!fuhao.count(tokens[i])) { //如果该元素不是运算符，直接入栈
                zhan.push(stoi(tokens[i]));  
            }
            else {
                int x2 = zhan.top();  //取出右操作数
                zhan.pop();
                int x1 = zhan.top();  //取出左操作数
                zhan.pop();
                //  计算对应的结果
                if (tokens[i] == "+") zhan.push(x1 + x2);
                if (tokens[i] == "-") zhan.push(x1 - x2);
                if (tokens[i] == "*") zhan.push(x1 * x2);
                if (tokens[i] == "/") zhan.push(x1 / x2);
            }
        }
        return zhan.top();
    }
};