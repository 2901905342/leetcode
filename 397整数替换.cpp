//题目描述：
// 给定一个正整数 n ，你可以做如下操作：
//
//如果 n 是偶数，则用 n / 2替换 n 。
//如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。
//n 变为 1 所需的最小替换次数是多少？
//

#include <iostream>
#include <vector>
using namespace std;


//官方解法  迭代
class Solution {
public:
    int integerReplacement(int n) {
        if (n == 1) {
            return 0;
        }
        if (n % 2 == 0) {
            return 1 + integerReplacement(n / 2);
        }
        return 2 + min(integerReplacement(n / 2), integerReplacement(n / 2 + 1));  //为了防止溢出  （n+1)/2   用  int (n/2) +1  代替
    }
};


//奇数能分类，
//4 * n + 14∗n + 1要么加一要么减一，除二以后变为2 * n2∗n或2 * n + 12∗n + 1，再运算以后变为nn或n + 1n + 1
//既然总要变成nn或n + 1n + 1, 减一运算到nn需要3步，而加一运算到nn需要4步；减一运算到n + 1n + 1需要4步，而加一运算到n + 1n + 1同样需要4步；
//也就是说4 * n + 14∗n + 1的时候减一，一定能构造出答案，比加一好或者和加一的效果一样。
//
//同理4 * n + 34∗n + 3的时候加一，也一定比减一好(除了3，3两次就到1了，加一再除再减反而会浪费步数)。
//


class Solution {
public:
    int integerReplacement(int n) {
        int count = 0;
        while (n > 1) {
            if (n % 2 == 0) {
                n /= 2;
                count += 1;
                continue;
            }
            if (n % 4 == 1 or n == 3) {
                n = (n - 1) / 2;
                count += 2;
                continue;
            }
            else {
                n = int(n / 2) + 1;
                count += 2;
                continue;
            }
        }
        return count;
    }
};

//贪心（位运算）
//我们可以从二进制的角度进行分析：给定起始值 nn，求解将其变为(000...0001)_2(000...0001)
//2​的最小步数。
//对于偶数（二进制最低位为 00）而言，我们只能进行一种操作，其作用是将当前值 xx 其进行一个单位的右移；
//对于奇数（二进制最低位为 11）而言，我们能够进行 + 1 或 - 1 操作，分析两种操作为 xx 产生的影响：
//对于 + 1 操作而言：最低位必然为 11，此时如果次低位为 00 的话， + 1 相当于将最低位和次低位交换；如果次低位为 11 的话， + 1 操作将将「从最低位开始，连续一段的 11」进行消除（置零），并在连续一段的高一位添加一个 11；
//对于 - 1 操作而言：最低位必然为 11，其作用是将最低位的 11 进行消除。
//因此，对于 xx 为奇数所能执行的两种操作， + 1 能够消除连续一段的 11，只要次低位为 11（存在连续段），应当优先使用 + 1 操作，但需要注意边界 x = 3x = 3 时的情况（此时选择 - 1 操作）。

