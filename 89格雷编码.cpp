////n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：
////每个整数都在范围[0, 2n - 1] 内（含 0 和 2n - 1）
////第一个整数是 0
////一个整数在序列中出现 不超过一次
////每对 相邻 整数的二进制表示 恰好一位不同 ，且
////第一个 和 最后一个 整数的二进制表示 恰好一位不同
////给你一个整数 n ，返回任一有效的 n 位格雷码序列 。



/////////////////////////思路//////////////////
//设 nn 阶格雷码集合为 G(n)，则 G(n + 1) 阶格雷码为：
//1.给 G(n)阶格雷码每个元素二进制形式前面添加 0，得到 G'(n)
//2.设 G(n) 集合倒序（镜像）为 R(n)，给 R(n) 每个元素二进制形式前面添加 1，得到 R'(n) 
//3.G(n + 1) = G'(n) ∪ R'(n)    拼接两个集合即可得到下一阶格雷码。


//根据以上规律，可从 00 阶格雷码推导致任何阶格雷码。
//代码解析：
//1.由于最高位前默认为 0，因此 G'(n) = G(n),只需在 res(即 G(n))后添加 R'(n) 即可；
//2.计算 R'(n):执行 head = 1 << i 计算出对应位数，以给 R(n) 前添加 1得到对应 R'(n)
//3.倒序遍历 res(即 G(n)G(n))：依次求得 R'(n) 各元素添加至 res 尾端，遍历完成后 res(即G(n + 1))。

#include"myhead.h"
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res; //初始Gn
        res.push_back(0);
        int head = 1;  //高位
        for (int i = 0; i < n; i++) { 
            for (int j = res.size() - 1; j >= 0; j--) {//倒叙遍历Gn
                res.push_back(head + res[j]);  //  计算并加上Rn得到G(n+1)
            }
            head = head << 1;
        }
        return res;
    }
};