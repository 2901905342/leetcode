//给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

#include "myhead.h"
/////思路1：简单模拟，时间复杂度（logn)
class Solution {
public:
    bool hasAlternatingBits(int n) {
        int flag = n % 2;
        n = n >> 1;
        while (n) {
            if (n % 2 == flag) return false;
            flag = n % 2;
            n = n >> 1;
        }
        return true;
    }
};

////思路2：官方解法二：位运算 ，时间复杂度O(1)
//对输入 n 的二进制表示右移一位后，得到的数字再与 n 按位异或得到 a。
//当且仅当输入 n 为交替位二进制数时，a 的二进制表示全为 1（不包括前导 0）。
//这里进行简单证明：当 aa 的某一位为 1 时，当且仅当 n 的对应位和其前一位相异。
//当 a 的每一位为 1 时，当且仅当 n的所有相邻位相异，即 n 为交替位二进制数。
//
//将 a 与 a + 1 按位与，当且仅当 a 的二进制表示全为1时，结果为 0。
//这里进行简单证明：当且仅当 a 的二进制表示全为 1 时，a + 1 可以进位，并将原最高位置为 0，按位与的结果为 0。
//否则，不会产生进位，两个最高位都为 1，相与结果不为 0。
//结合上述两步，可以判断输入是否为交替位二进制数。
class Solution {
public:
    bool hasAlternatingBits(int n) {
        long a = n ^ (n >> 1);
        return (a & (a + 1)) == 0;
    }
};

